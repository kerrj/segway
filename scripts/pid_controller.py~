#!/usr/bin/env python3
'''simple pid controller for the segway'''

import rospy
import numpy as np
from segway.msg import AngleReading,EncoderReading,MotorCommand
RATE=50
WHEEL_RAD = .08
th = None
thdot = None
x = None
xdot = None
def clip(v,minv,maxv):
    return min(max(v,minv),maxv)
class PID(object):
    def __init__(self,p,i,d,ioutputcap):
        #icap is in units of output, ie capped output after multiplying by i
        self.p=p
        self.i=i
        self.d=d
        self.icap=ioutputcap/self.i if self.i>0 else 1
        self.sum=0
    def step(self,err,derr,dt):
        self.sum+=dt*err
        self.sum=clip(self.sum,-self.icap,self.icap)
        return self.p*err+self.i*self.sum+self.d*derr

def angleCB(msg):
    global th,thdot
    th=msg.th
    thdot=msg.thdot
def encoderCB(msg):
    global x,xdot
    #just use the left value for now
    x = msg.leftAngle*WHEEL_RAD
    xdot = msg.leftVel*WHEEL_RAD

rospy.init_node("pid")
angleSub = rospy.Subscriber('angle',AngleReading,angleCB,queue_size=1)
encoderSub = rospy.Subscriber('encoders',EncoderReading,encoderCB,queue_size=1)
controlPub = rospy.Publisher('cmd_vel',MotorCommand,queue_size=1)

rate=rospy.Rate(RATE)
pid=PID(10,2,1,3)
while not rospy.is_shutdown():
    rate.sleep()
    if th is None or x is None:
        print("no data")
        continue
    command=MotorCommand()
    command.stamp=rospy.get_rostime()
    u=pid.step(th,thdot)
    command.left=u
    command.right=u
    controlPub.publish(command)

